---
name: MySQL读书笔记
layout: post
title:  "MySQL读书笔记"
info: "MySQL读书笔记"
date:   2019-05-05
categories: WORK
tags: [MySQL]
coverimg: "https://ws1.sinaimg.cn/large/88b26e1cgy1fx7cwh57tlj22kw3vc1ky.jpg"
---

## 连接
##### MacOS下安装
```shell
brew install mysql
````
##### mysqld_safe可执行文件会调用mysqld，并启动一个监控进程，挂掉后重启
##### MySQL客户端连接指定数据库(TCP/IP协议，远程连接)
```shell
mysql -h127.0.0.1 -P3306 -uroot -p123 -Dmysql --default-character-set=utf8
```
##### MySQL客户端连接指定数据库(Unix域套接字文件,本地连接默认监听/tmp/mysql.sock)
```shell
mysql --protocol=socket -uroot -p123 -Dmysql --default-character-set=utf8
```
##### 客户端和服务器交互可分类
    1.连接管理
        每个连接为一个线程
    2.解析与优化
        查询缓存
        语法解析
        查询优化
    3.存储引擎
        InnoDB 具备外键支持功能的事务存储引擎
        MyISAM 主要的非事务存储引擎
        MEMORY 基于内存的表（子查询，uniue,distinct临时表）
        修改已有表的存储引擎
            alter table user engine=MyISAM
            
## 编码
##### 常用字符集
名称 | 解释 | 编码字节数
:----|:----|:----
ASCII | 128个字符 | 1
ISO 8859-1(latin1) | 256个字符,在ASCII的基础上扩充128个西欧字符 | 1
GB2312 | 汉字，拉丁字母，希腊字母，日文，俄语 | 如字符在ASCII字符集中使用1个字节编码，否则两个
GBK | 在GB2312的基础上扩充 | 编码方式兼容GB2312
UTF-8 | 收录所有字符集 | 采用变长编码，编码一个字符需要使用1~4个字节

##### MySQl中的utf8和utf8mb3
名称 | 解释
:----|:----
utf8mb3(简写为utf8) | 阉割版的utf8字符集，使用1~3个字节表示字符
utf8mb4 | 标准的utf8字符集，使用1~4个字节表示字符，可存储emoji表情

##### 每个字符集对应不同计较规则，如结果不符合预期，可确认字符集的比较规则

## 存储引擎
    MySQL服务器负对表中数据的读取和写入工作的部分定义为存储引擎
    不同的存储引擎一般是由不同的人为实现不同的特性而开发的，真实数据在不同存储引擎中存放的格式一般是不同的
    
### InnoDB
    InnoDB是将数据存储在磁盘上的存储引擎，数据读取与写入以页为单位在磁盘和内存键交互，页的大小一般为16K
    
    1.InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做数据页。

    2.一个数据页可以被大致划分为7个部分，分别是

        File Header，表示页的一些通用信息，占固定的38字节。
        Page Header，表示数据页专有的一些信息，占固定的56个字节。
        Infimum + Supremum，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的26个字节。
        User Records：真实存储我们插入的记录的部分，大小不固定。
        Free Space：页中尚未使用的部分，大小不确定。
        Page Directory：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。
        File Trailer：用于检验页是否完整的部分，占用固定的8个字节。
    3.每个记录的头信息中都有一个next_record属性，从而使页中的所有记录串联成一个单链表。
    
    4.InnoDB会为把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个槽，存放在Page Directory中，所以在一个页中根据主键查找记录是非常快的，分为两步：
        通过二分法确定该记录所在的槽。
        通过记录的next_record属性遍历该槽所在的组中的各个记录。
    5.每个数据页的FileHeader部分都有上一个和下一个页的编号，所以所有的数据页会组成一个双链表。
    
    6.为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的LSN值，如果首部和尾部的校验和和LSN值校验不成功的话，就说明同步过程出现了问题。
##### 目前四中行格式
    1.Compact
    2.Redundant
    3.Dynamic
    4.Compressed
    
##### Compact行格式分类两部分
    1.记录的额外信息
        边长字段长度列表 
        NULL值列表
        记录头信息 
    2.记录的真实数据
        每列的真实数据


##### 边长字段长度列表
    变长数据类型如VARCHAR(n),TEXT,BLOB所占用的存储空间分为真正的数据内容和占用的字节数
    所有的变长字段的真实占用字节长度存逆序存放
    每列的真实的数据存放在记录的真实数据段中
    如果设置字符集为变长字符集(GBK[1-2],UTF-8[1-3]),CHAR(N)类型也会存储到该列
##### NULL值列表
    存放是否允许为NULL字段的状态，逆序存放
    实现为布隆过滤器，NULL则对应位为1，否则为0
    必须使用整数字节位表示，高位补零
    用16进制表示
    当某一列为NULL时对应的位为1，对应的真实数据不存储，节省空间
##### 记录头信息
    由5个字节40个位组成
    具体信息自行查看
    delete_mask：
        该记录是否被删除，0表示未删除，1为删除
        被删除的记录不会被立即删除，会被标记为1，加入垃圾链表
        垃圾链表中的空间成为可重用空间，如有新纪录插入可覆盖
    min_rec_mask
        B+树每层分子叶节点为1
    heap_no
        表示当前记录在本页中的位置
        默认从2开始，0和1为自动生成最大记录和最小记录
    record_type
        0表示普通记录
        1表示B+树非叶节点记录
        2表示最小记录
        3表示最大记录
    next_record
        从当前记录的真实数据到下一条记录的真实数据的地址偏移量
        下一条记录指的是按照主键从小到大的顺序的下一条记录
        我们的记录按照主键有小到大的顺序形成一个单链表
        不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的
##### 记录的真实数据
    除了用户数据MySQL会对每个记录添加三个隐藏列
    DB_ROW_ID,如用户列无unique列则自动创建，否则不自动创建
    DB_TRX_ID,事务ID
    DB_ROLL_PTR,回滚指针
    
##### 叶目录
    1.将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。

    2.每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录，也就是该组内共有几条记录。

    3.将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的Page Directory，也就是页目录（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为槽（英文名：Slot），所以这个页面目录就是由槽组成的。
    
    4.最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数只能在 1~8 条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间
    
##### 在一个数据页中查找指定主键值的记录的过程分为两步
    1.通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。
    2.通过记录的next_record属性遍历该槽所在的组中的各个记录。
    
##### Page Header（页面头部）
    数据页中存储的记录的状态信息
    
##### File Header（文件头部）
    它描述了一些针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁
    
##### File Trailer
    校验内存中的数据和磁盘中存储的数据的一致性，针对各种突发状况，保持数据的一致性
    叶的通用类型
    
## 索引
    下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程我们也可以称为页分裂
    目录项记录和普通用户记录组成B+树
#### 聚簇索引
    1.使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
        页内的记录是按照主键的大小顺序排成一个单向链表。
        各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。
        存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。

    2.B+树的叶子节点存储的是完整的用户记录。
        所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。
我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX语句去创建（后边会介绍索引相关的语句），InnoDB存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的索引即数据，数据即索引。

#### 二级索引，联合索引
    1.使用需要建立索引的列生成B+数
    2.B+树存储索引列和主键
    3.Log(n)时间复杂度查找出主键后需回表查询完整记录
    
#### B+树的形成过程
    1.初始只有一个页，该页就是根节点，数据存储在该页中
    2.当初始页数据超出后将该页用户数据复制一份到另一页，初始页升级为目录项页，该过程成为也分裂
    3.一个B+树索引的根节点自诞生之日起，便不会再移动
    
### MyISAM
    1.将表中的记录按照记录的插入顺序单独存储在一个文件中，称之为数据文件
    2.MyISAM存储引擎的表会把索引信息另外存储到一个称为索引文件的另一个文件中
    3.MyISAM会单独为表的主键创建一个索引，只不过在索引的叶子节点中存储的不是完整的用户记录，而是主键值 + 行号的组合
    4.可以对其它的列分别建立索引或者建立联合索引，原理和InnoDB中的索引差不多，不过在叶子节点处存储的是相应的列+行号。这些索引也全部都是二级索引
    5.MyISAM会直接在索引叶子节点处存储该条记录在数据文件中的地址偏移量,使用地址偏移量直接到文件中取数据的
    
### 索引的代价
    1.空间代价，每个索引为一颗B+树，树的每一个节点是16KB的页
    2.时间代价，每次增删改操作都需维护各个索引
    
### B+树使用索引的条件
    1.全值匹配
    2.匹配左边的列
    3.用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列
    4.左前缀匹配
        如需匹配右后缀可考虑字符串逆序存放
    5.匹配范围值
    6.精确匹配某一列并范围匹配另一列
    7.用于排序
        如无索引需将所有数据加载到内存中使用排序算法排序，如内存有限则借助磁盘存放中间结果
    8.用于分组 group by 
        如无索引需在内存中实现

### 回表的代价
    尽量避免回表，最好在查询列表里只包含索引列
    需要回表的记录越多，使用二级索引的性能就越低
    查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用二级索引 + 回表的方式
    
### 创建索引原则
    1.只为用于搜索、排序或分组的列创建索引
    2.最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好
    3.索引列的类型尽量小
        1.数据类型越小，在查询时进行的比较操作越
        2.数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/O带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率
    4、索引字符串值的前缀name(10)
        索引列前缀的方式无法支持使用索引排序
    5.让索引列在比较表达式中单独出现
        避免在字段参加运算
    6.主键插入顺序
        尽量使用自增，减少页面分裂和记录位移造成的性能损耗
    7.避免冗余索引
        联合索引和单列索引重复
        
        
## MySQL的数据目录
### 数据库和文件系统的关系
    InnoDB 、 MyISAM 这样的存储引擎都是把表存储在文件系统上的
    
### 表在文件系统中的表示
    1.表结构的定义
        InnoDB和MyISAM这两种存储引擎都在数据目录下对应的数据库子目录下创建表名.frm文件
        以二进制形式存储
    2.表中的数据
        InnoDB提出了一个表空间或者文件空间的概念，它可以对应文件系统上一个或多个真实文件
        每一个表空间可以被划分为很多很多很多个页，我们的表数据就存放在某个表空间下的某些页里
        表空间划分为几种不同的类型
        
        系统表空间
            系统自动创建表空间，只有一份
            从MySQL5.5.7到MySQL5.6.6之间的各个版本中，我们表中的数据都会被默认存储到这个系统表空间
        独立表空间
            在MySQL5.6.6以及之后的版本中，InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间
            使用独立表空间来存储表数据的话，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名添加.ibd的扩展名
            
        MyISAM数据存储
            在文件系统中也是使用不同的文件来存储数据文件和索引文件
            表数据都存放到对应的数据库子目录下
            .MYD文件存储用户记录
            .MYI文件存储索引
            
        视图在文件系统中的表示
            视图是虚拟的表，也就是某个查询语句的一个别名，所以在存储视图的时候是不需要存储真实的数据的，只需要把它的结构存储起来就行了
            
### 文件系统对数据库的影响
    1.数据库名称和表名不得超过文件系统所允许最大长度
    2.特殊字符
        MySQL会把数据库名和表名中所有除数字和拉丁字母以外的所有字符在文件名里都映射成 @+编码值的形式作为文件名
    3.文件长度受文件系统最大长度限制

## InnoDB表空间
    
### 独立表空间结构
    1.每页中的用户记录为细小单位
    2.1-8个记录为一个槽
    3.16KB为一页，单向链表连接的槽
    4.连续的64个页为一区，一区占用1M空间
    5.每256个区为一组
    存放叶子节点的区的集合为一个段
    存放非叶子节点的集合也是一个段
    
### 区的分类
    1.空闲的区：现在还没有用到这个区中的任何页面。
    2.有剩余空间的碎片区：表示碎片区中还有可用的页面。
    3.没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面。
    4.附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位
    5.需要再次强调一遍的是，处于FREE、FREE_FRAG以及FULL_FRAG这三种状态的区都是独立的，算是直属于表空间；而处于FSEG状态的区是附属于某个段的。
    
## 单表查询
### 访问方法
名称 | 中文解释 | 说明
:----|:-----|:----
const | 常数级别 | 只能在主键列或者唯一二级索引列和一个常数进行等值比较时才有效, is null无效
ref | 稍慢于const | 使用普通二级索引作为查询条件，回表次数可能大于一，is null有效
ref_or_null | 普通常数和null | ref的基础上or key is null
range | 使用索引范围匹配 | 回表次数大于一
index | 所需要查询的值都在某个索引中 | 由于联合索引记录比聚簇索引小，遍历成本低
all | 全表扫描 | 直接扫描聚簇索引

### 索引合并
    在一次查询中可以使用多个二级索引，可在回表前进行取交集操作
    
## 联合查询
    1.内连接
    2.外连接
        左外连接 左侧表为驱动表
        右外连接 右侧表为驱动表
        

### where & on
    WHERE子句中的过滤条件就是我们平时见的那种，不论是内连接还是外连接，凡是不符合WHERE子句中的过滤条件的记录都不会被加入最后的结果集。
    
    对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用NULL值填充。

    需要注意的是，这个ON子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的，所以如果把ON子句放到内连接中，MySQL会把它和WHERE子句一样对待，也就是说：内连接中的WHERE子句和ON子句是等价的。
    
    内连接和外连接的根本区别就是在驱动表中的记录不符合ON子句中的连接条件时不会把该记录加入到最后的结果集

### 连接的原理
    两表连接来说，驱动表只会被访问一遍，但被驱动表却要被访问到好多遍
    
## 基于成本的优化
    1.I/O成本
        将磁盘中内容加载到内存中消耗的时间成本
    2.CPU成本
        匹配 搜索条件，排序操作所消耗的时间为CPU成本
        
### 单表查询的成本
    1.根据搜索条件，找出所有可能使用的索引
    2.计算全表扫描的代价
    3.计算使用不同索引执行查询的代价
    4.对比各种执行方案的代价，找出成本最低的那一个
    
### 基于索引统计数据的成本计算
    使用二级索引列IN操作在IN容器小于200时候使用index dive方式
    超过200直接采用全表扫描
    200的阈值可通过eq_range_index_dive_limit来更改
    
### 连接查询的成本
    MySQL中连接查询采用的是嵌套循环连接算法，驱动表会被访问一次，被驱动表可能会被访问多次
    连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本
    
### InnoDB统计数据的收集
    1.永久性的统计数据
        这种统计数据存储在磁盘上，也就是服务器重启之后这些统计数据还在。

    2.非永久性的统计数据
        这种统计数据存储在内存中，当服务器关闭时这些这些统计数据就都被清除掉了，等到服务器重启之后，在某些适当的场景下才会重新收集这些统计数据。
        
### 基于规则的优化
    MySQL会自动将查询语句转换成自认为高效的执行形式，这个过程称为查询重写
    
    1.条件化简
        1.移除不必要的括号
        2.常量传递
        3.等职传递
        4.移除无用条件
        5.表达式计算
        6.HAVING字句和WHERE字句合并
        7.常量表检测
    2.外连接消除
        将外连接改写为内连接
    3.子查询优化
        将子查询改写为联合查询