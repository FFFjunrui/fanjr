---
name: 架构整洁之道
layout: post
title:  "架构整洁之道"
info: "架构整洁之道"
date:   2019-05-05
categories: WORK
tags: [Linux, 读书]
coverimg: "https://ws1.sinaimg.cn/large/88b26e1cgy1fx7cwh57tlj22kw3vc1ky.jpg"
---

## 序一
- 分离控制和逻辑
- 所谓控制就是对程序流转的与业务逻辑无关的代码或系统的控制（多线程，异步，服务发现，部署，弹性伸缩）
- 所谓逻辑则是实实在在的业务逻辑，是解决用户问题的逻辑
- 控制和逻辑构成了整体的软件复杂度，有效地分离控制和逻辑会让你的系统得到最大优化
- 简单VS简陋，平衡VS妥协，迭代VS半成品

## 序二
- 所谓架构就是用最小的人力成本来满足构建和维护系统需求

## 序言
- 无论从哪个角度分析软件系统，都不可能面面俱到，在一定程度上做到抓大放小，把握重点，但是还是不可避免措施细节信息
- 设计软件架构过程中必须理解和遵守现实的约束条件，CPU速度和网络带宽往往在很大程度上决定了系统的性能，而内存和存储空间的大小也会大幅影响代码设计野心
- 软件架构是一个猜想，只有通过实际实现和测量才能证实
- 走快的唯一方法是先走好

## 第二部分，从基础构建开始：编程范式
### 3. 编程范式总览
- 结构化编程对程序控制权的直接转义进行了限制和规范（限制goto语句）
- 面向对象编程对程序控制权的间接转移进行了限制和规范（限制函数指针）
- 函数式编程对程序中的赋值进行了限制和规范（限制赋值语句）
- 这三个编程范式都对程序员提出了新的限制，每个范式都约束了某种编写代码的方式，没有一个编程范式是在增加新能力
- 多态是我们跨越架构边界的手段，函数式编程是我们规范和限制数据存放位置与访问权限的手段，结构化编程则是各个模块的算法实现基础，这和软件架构的三大关注点不谋而合，功能性，组件独立性以及数据管理

### 4. 结构化编程
- 用顺序结构，分支结构，循环结构这三种结构可构造出任何程序
- 科学理论和科学定律的特点就是它们可以被证伪，但是没有办法被证明
- 结构化编程范式中最具价值的地方就是，它赋予了我们创造可证伪程序单元的能力
- 在架构设计领域，功能性降解拆分仍然是最佳实践之一

### 5. 面向对象
- 封装
- 继承
- 多态

### 6. 函数式编程
- 函数式编程语言中的变量是不可变的
- 一切并发应用遇到的问题，一切由于使用多线程，多处理器而引起的问题，如果没有可变变量的话都不可能发生
- 一个架构设计良好的应用程序应该将状态修改的部分和不需要修改状态的部分隔离成单独的组件，然后用合适的机制来保护可变量
- 软件架构师应该着力与将大部分处理逻辑都归于不可变组件中，可变状态组件的逻辑应越少越好
- 我们不需要这个设计永远可行，只需在整个程序的生命周期内有足够的存储和处理能力来满足它

## 第三部分设计原则
### SOLID原则
- SRP单一职责原则，一个转件系统的最佳结构高度依赖于开发这个系统的组织的内部结构，这样每个软件模块都有且只有一个需要被改变的理由
- OCP开闭原则，如果软件系统想要更容易被改变，那么其设计就必须允许新增代码来修改系统行为，而非只能靠修改原来的代码
- LSP里氏替换原则，如果想用可替换的组件来构建软件系统，那么这些组件就必须遵守同一个约定，以便这些组件可以互相替换
- ISP接口隔离原则，在设计中避免不必要的依赖
- DIP依赖反转原则，高层策略性的代码不应该依赖实现底层细节的代码，实现底层细节的代码应该依赖高层策略性代码

### 7. SRP：单一职责原则
- 任何一个软件模块都应该只对某一类行为者负责
- 单一职责原则主要讨论的是函数和类的关系，在组件层面，我们可以称之为共同闭包原则，在软件架构层面，它则是用于奠定架构边界的变更轴心

### 8. OCP：开闭原则
- 设计良好的计算机软件应该易于拓展，同时抗拒修改
- 一个设计良好的计算机系统应该在不需要修改的前提下就可以轻易被拓展
- OCP是我们进行系统架构设计的主导原则，其主要目标是让系统易于拓展，同时限制其每次被修改所影响的范围
- 实现方式是通过将系统划分为一系列组件，并将这些组件间的依赖关系按层次结构进行组织，使得高阶组件不会因低阶组件被修改而受到影响

### 9. LSP：里氏替换原则
- LSP可以且应被应用于软件架构层面，因为一旦违背了可替换性，该系统架构就不得不为此增加大量复杂的应对机制

### 10. ISP：接口隔离原则
- 任何层次的软件设计如果依赖了它并不需要的东西，就会带来意料之外的麻烦

### 11. 依赖反转原则
- 如果想要设计一个灵活的系统，在源代码层次的依赖关系中就应该多引用抽象类型，而非具体实现
- 我们每次修改抽象接口的时候，一定也会去修改对应的具体实现。但反过来当我们修改具体实现时，却很少需要去修改相应的抽象结构，所以我们可以认为接口比实现更稳定
- 优秀的软件设计师和架构师会花费大精力来设计接口，以减少未来对其进行改动，毕竟争取在不修改接口的情况下为软件增加新的功能是软件设计的基础常识
- 设计原则的编码遵守
```
1. 应在代码中多使用抽象接口，尽量避免使用那些多变的具体实现类
2. 不要在具体实现类上创建衍生类
3. 不要覆盖包含具体实现的函数
4. 应避免在代码中写入任何具体实现相关的名字，或者其他容易变动的事物的名字
```

## 第四部分组件构建原则
### 12. 组件
- 组件是软件的部署单元，是整个软件系统在部署过程中可以独立完成部署的最小实体
- 我们常常会在程序运行时插入某些动态链接文件，这些动态链接文件所使用的就是软件架构中组件的概念

### 13. 组件聚合
#### 复用/发布等同原则
- 软件复用的最小粒度应等同于其发布的最小粒度
- 一个组件不能由一组毫无关联的类和模块组成，它们之间应该有一个共同的主题或大方向

#### 共同闭包原则
- 我们应该将那些会同时修改，并且为相同目的而修改的类放到同一个组件中
- 因为如果这些变更都集中在同一个组件中，我们就只需要重新部署该组件，其他组件则不需要被重新验证，重新部署

#### 共同复用原则
- 不要强迫一个组件的用户依赖他们不需要的东西
- 不是紧密相连的类不应该被放在同一个组件里
- 不要依赖不需要用到的东西

### 14.组件耦合
- 组件依赖关系图中不应该出现环
- 依赖关系必须要指向更稳定的方向
- 一个组件的抽象花程度与其稳定性保持一致

### 15. 什么是软件架构
- 软件架构师需要是程序员，并且必须一直坚持做一线程序员，体会设计带来的直接感觉
- 软件系统这项工作的实质就是规划如何将系统切分成组件，并安排好组件之间的排列关系，以及组件之间互相通信的方式
- 设计架构的目的就是为了在工作中更好地对这些组件进行研发，部署，运行以及维护
- 如果想设计一个便于推进各项工作的系统，其策略就是要在设计中尽可能长时间地保留尽可能多的可选项
- 软件架构设计的主要目标是支撑软件系统的全生命周期，设计良好的架构可以让系统便于理解，易于修改，方便维护，并且能轻松部署
- 软件架构的终极目标就是最大化程序员的生产力，同时最小化系统的总运营成本
- 软件被发明出来就是因为我们需要一种灵活和便捷的方式来改变机器的行为，而软件的灵活性则取决于系统的整体状况，组件的布置以及组件之间的连接方式
- 所有软件系统都可以降解为策略与细节这两种主要元素
- 策略体现的是软件中所有的业务规则与操作过程，是系统真正的价值所在
- 细节是指那些让操作该系统的人，其他系统以及程序员们与策略进行交互，但是又不会影响到策略本身的行为，包括I/O设备，数据库，Web系统，服务器，框架，交互协议等
- 软件架构师的目标是创建一种系统形态，该形态会以策略为最基本的元素，并让细节与策略脱离关系，以允许在具体决策过程中推迟或延迟与细节相关的内容
- 在开发的早期阶段应该无需选择数据库系统，因为软件的高层策略不应该关系其底层到底使用哪一种数据库
- 在开发的早期阶段也不应该选定使用的web服务，因为高层策略不应该知道自己未来要以网页形式发布
- 在开发早期阶段不应该过早地采用REST模式，因为软件的高层策略应该和外部接口无关
- 在开发的早期阶段不应该过早地采用依赖注入框架，因为高层策略不应该操心如何解析系统的依赖关系
- 如果在开发高层策略时有意地让自己摆脱具体细节的纠缠，我们就可以将与具体实现的细节决策推迟或延后，因为越到项目的后期，我们就拥有越多的信息来做出合理的决策，同时可以让我们有机会做不同的尝试
- 一个优秀的软件架构师应该致力于最大化可选项数量
- 优秀的软件架构师会小心地将软件的高层策略与其底层实现隔离开，让高层策略与实现细节脱钩，使其策略部分完全不需要关心底层细节，当然也不会对这些细节有任何形式的依赖
- 优秀的架构师所设计的策略应该允许系统尽可能地推迟与实现细节相关的决策，越晚做决策越好

### 16. 独立性
- 一个设计良好的软件架构必须支持一下几点
```
1. 系统的用例与正常运行
2. 系统的维护
3. 系统的开发
4. 系统的部署
```
- 一个系统的结构必须能支持其自身的设计意图
- 一个设计良好的架构在行为上对系统最重要的作用就是明确和显式地反映系统设计意图的行为，使其在架构层面可见
- 优秀的架构师可以将多进程多线程或微服务作为保留选项
- 康威定律：任何一个组织在设计系统时，往往会复制出一个与该组织内部沟通结构相同的系统
- 一个设计良好的结构通常不会依赖于成堆的脚本于配置文件，也不需要用户手动创建一堆有严格要求的目录与文件
- 一个设计良好的软件架构可以让系统在构建完成之后立刻就能部署
- 一个设计良好的架构应该通过保留可选项的方式，让系统在任何情况下都能方便的做出必要的变更
- 从用例的角度来看，架构师的目标是让系统结构支持其所需要的所有用例，但问题恰恰是我们无法预知全部的用例
- 架构师可以通过采用单一职责原则和共同闭包原则，以及既定的系统设计意图来隔离那些变更原因不同的部分，集成变更原因相同的部分
- 如果我们按照变更原因的不同对系统进行解耦，就可以持续地向系统内添加新的用例，而不会影响旧有的用例
- 如果我们同时对支持这些用例的UI和数据库也进行了分组，那么每个用例使用的就是面向不同UI和数据库，因此增加新用例就更不太可能会影响旧有的用例
- 只要系统按照其水平分层和用例进行了恰当的解耦，整个系统的架构就可以支持多团队开发，不管团队组织形式是分功能开发，分组件开发，分层开发，还是按照别的什么变量分工都可以
- 架构师们常常会钻进一个牛角尖-害怕重复，一定要确保消除动作只针对那些真正意义上的重复
- 源码层次，系统所有的组件都会在同一地址空间内执行，它们会通过简单的函数调用来进行彼此交互，这类系统在运行时是作为一个执行文件被统一加载到计算机内存中的，这种模式叫做单体模式
- 部署层次，可以控制部署单元（jar文件，DLL，共享库）之间的依赖关系，以此来实现一个模块的变更不会导致其他模块的重新构建和部署，这种模式下大部分组件可能依然运行在同一个地址空间内，通过彼此的函数调用通信，但有个别组件可能会运行在同一个处理器下的其他进程内，使用跨进程通信，通过socket或共享内存进行通信，这里最重要的是这些组件的解耦产生出许多可独立部署的单元
- 服务分层，可以将组件间的依赖关系降低到数据结构级别，然后仅通过网络数据包来进行通信，这样系统的每个执行单元在源码层和二进制层都会是一个独立的个体，它们的变更不会影响其他地方
- 一个设计良好的架构应该允许一个系统从单体结构开始，以单一文件的形式部署，然后逐渐成长为一组互相独立的可部署单元，甚至是独立的服务或者微服务，最后还能随着情况变化，允许系统逐渐退回到单体结构
- 一个系统所适用的解耦模式可能会随着时间而变化，优秀的架构师应该能预见这一点，并且做出相应的对策

### 17. 划分边界
- 软件架构设计本身就是一门划分边界的艺术
- 边界的作用是将软件分割成各种元素，以便约束边界两侧的依赖关系
- 架构师所追求的目标是最大限度地降低构建和维护一个系统所需的人力资源
- 一个设计良好的系统架构不应该依赖细节，而因该尽可能地推迟细节性的决策，并致力于将这种推迟所产生的影响降到最低
- I/O是无关紧要的
- 为了在软件架构中画边界线，需要先将系统分割为组件，其中一部分是系统的核心业务逻辑组件，而另一部分则是与核心业务逻辑无关但负责提供必要功能的插件，通过对源码的修改，让非核心组件依赖于系统的核心业务逻辑组件

### 18. 边界剖析
- 构造合理的跨边界调用需要对源码的依赖关系进行合理管控，当一个模块的源码发生变更，其他模块的源码可能也随之发生变更或从新编译，并需要重新部署
- 最简单的跨边界调用形式是由底层客户端来调用高层服务函数，这种依赖关系在运行时和编译时会保持指向一致，都是从底层组件指向高层组件
- 在单体结构中，组件之间的交互一般情况下都只是普通的函数调用，迅速而廉价，这意味着这种跨源码层次解耦边界的通信会很频繁
- 系统架构最常见的物理边界形式为动态链接库(.Net的DLL,Java的jar文件,UNIX的共享库等),这种类型的组件在部署时不需要重新编译，它们都是以二进制形式或者其他等价的可部署形式交付的
- 按部署层次解耦的组件之间的跨边界调用也只是普通的函数调用，很廉价
- 本地进程之间的跨边界通信需要用到系统调用，数据的编码和解码，以及进程间的上下文切换，成本相对来说更高一些，需谨慎地控制通信的次数
- 服务之间的跨边界通信相对于函数调用来说，速度是非常缓慢的，在划分架构边界时，一定要尽可能控制通信次数，这个层次上的通信必须能够适应高延时情况
- 一个系统中通常会包含高通信量，低延迟的本地架构边界和低通信量，高延迟的服务边界

### 19. 策略与层次
- 本质上所有的软件系统都是一组策略语句的集合
- 计算机程序就是一组仔细描述如何将输入转化为输出的策略语句的集合
- 架构设计的工作常常需要将组件重新排列成一个有向无环图，图中每一个节点代表的是一个拥有相同层次策略的组件，每一条单向链接都代表了组件之间的依赖关系，它们将不同级别的组件链接起来
- 一条策略距离系统的输入输出越远，它所属的层次就越高，而直接管理输入输出的策略在系统中的层次是最低的

### 20. 业务逻辑
- 业务逻辑是一个软件系统存在的意义，它们属于核心功能，是系统用来赚钱或省钱的那部分代码，是整个系统中的皇冠明珠
- 业务逻辑应该保持纯净，不要掺杂用户界面所使用的数据库相关的东西

### 21. 尖叫的软件架构
- 一个良好的架构设计应该围绕着用例来展开，这样的架构设计可以脱离框架，工具及使用环境的情况下完整地描述用例
- 良好的架构设计应该尽可能地允许用户推迟和延后决定采用什么框架，数据库，Web服务以及其他环境相关的工具
- 良好的架构设计应该只关注用例，并能将它们与其他周边因素隔离

### 22. 整洁架构
- 通过将系统划分层次，并确保这些层次遵守依赖关系规则，就可以构建出一个天生可测试的系统

### 23. 展示器和谦卑对象
- 跨边界通信需要用到某种简单的数据结构，而边界会将系统分割为难以测试的部分和容易测试的地方，通过在系统的边界运用谦卑对象模式，可以大幅提高整个系统的可测试性

### 24. 不完全边界
- 构建不完全边界的一种方式就是将系统分割成一系列可以独立编译，独立部署的组件后，再把它们构建成一个组件
- 架构师的职责之一就是预判未来哪里有可能会需要设置架构边界，并决定应该以完全形式还是不完全形式来实现

### 25. 层次与边界
- 系统通常分为三个组件：UI，业务逻辑，数据库
- 不应该将未来的需求抽象化

### 26. Main组件
-  Main组件也可以被视为应用程序的一个插件--这个插件负责设置起始状态，配置信息，加载外部资源，最后将控制权转交给应用程序的其他高层组件

### 27. 宏观与微观
- 架构设计的任务就是找到高层策略与低层细节之间的架构边界，同时保证这些边界遵守的依赖关系规则
- 微服务之间的接口一定是充分定义的
- 虽然服务化可能有助于提升系统的可拓展性和可研发型，但服务本身却并不能代表整个系统的架构设计
- 系统的架构是由系统内部的架构边界，以及边界之间的依赖关系所定义的，与系统中各组件之间的调用和通信方式无关

### 28. 测试边界
- 测试并不是独立于整个系统之外的，它们是系统的一个重要组成部分

### 29. 整洁的嵌入式架构
- 虽然软件本身并不会随时间推移而磨损，但硬件及其固件却会随时间推移而过时，随即也需要对软件做出相应改动
- 软件构建的三个阶段
```
1. 先让代码工作起来
2. 然后再试图将它变好
3. 最后再试着让它运行地更快
```
### 30. 数据库只是实现细节
- 数据控只是在硬盘和内存之间互相传输数据的一种手段，可以认为是一个长期存储数据的，装满字节的大桶
- 当涉及数据存储时，这些操作通常是被封装起来，隔离在业务逻辑之外
- 数据的组织结构，数据的模型，都是系统架构中的重要部分，但从磁盘上存储，读取数据的机制和手段却没那么重要
- 数据本身很重要，但数据库系统仅仅是一个实现细节

### 31. Web是实现细节
- GUI只是一个实现细节，而Web则是GUI的一种，我们需要将这类细节与核心业务逻辑隔离开来

### 32. 应用程序框架是实现细节
- 面临框架选择时，尽量不要草率地做出决定，尽肯能长时间将框架留在架构边界之外，不雅被框架束缚

### 33. 案例分析：视频销售网站
- 第一根据单一职责原则对所使用的系统的各个角色进行隔离，第二对依赖关系原则的应用

### 34. 拾遗
- 按层封装
- 按功能封装
- 按组件封装
- 如果不考虑具体实现细节，再好的设计也无法长久，必须要将设计映射到对应的代码结构上，考虑如何组织代码树，以及在编译期和运行期采用哪种解耦合的模式
