webpackJsonp([2],{zfN7:function(E,a,t){"use strict";Object.defineProperty(a,"__esModule",{value:!0});var B={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var E=this,a=E.$createElement,t=E._self._c||a;return t("div",{staticClass:"content"},[t("hr"),E._v(" "),t("h2",{attrs:{id:"name%3A-%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0layout%3A-posttitle%3A-%22%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%22info%3A-%22%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%22date%3A-2019-05-05categories%3A-worktags%3A-%5Blinux%2C-%E5%86%85%E6%A0%B8%2C-%E8%AF%BB%E4%B9%A6%5Dcoverimg%3A-%22https%3A%2F%2Fws1.sinaimg.cn%2Flarge%2F88b26e1cgy1fx7cwh57tlj22kw3vc1ky.jpg%22"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#name%3A-%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0layout%3A-posttitle%3A-%22%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%22info%3A-%22%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%22date%3A-2019-05-05categories%3A-worktags%3A-%5Blinux%2C-%E5%86%85%E6%A0%B8%2C-%E8%AF%BB%E4%B9%A6%5Dcoverimg%3A-%22https%3A%2F%2Fws1.sinaimg.cn%2Flarge%2F88b26e1cgy1fx7cwh57tlj22kw3vc1ky.jpg%22","aria-hidden":"true"}},[E._v("#")]),E._v(' name: 内核设计与实现\nlayout: post\ntitle:  "内核设计与实现"\ninfo: "内核设计与实现"\ndate:   2019-05-05\ncategories: WORK\ntags: [Linux, 内核, 读书]\ncoverimg: "https://ws1.sinaimg.cn/large/88b26e1cgy1fx7cwh57tlj22kw3vc1ky.jpg"')]),E._v(" "),t("h2",{attrs:{id:"3.-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#3.-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86","aria-hidden":"true"}},[E._v("#")]),E._v(" 3. 进程管理")]),E._v(" "),t("h4",{attrs:{id:"1.-%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#1.-%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87","aria-hidden":"true"}},[E._v("#")]),E._v(" 1. 进程上下文")]),E._v(" "),t("ul",[t("li",[E._v("代码从可执行文件载入到进程的地址空间执行")]),E._v(" "),t("li",[E._v("一般程序在用户空间执行")]),E._v(" "),t("li",[E._v("当一个程序执行了系统调用或者触发异常，则陷入内核空间")]),E._v(" "),t("li",[E._v("如无更高优先级进程需要执行并由调度器做出相应调整，在内核态退出时，程序恢复在用户空间继续执行")])]),E._v(" "),t("h4",{attrs:{id:"2.-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#2.-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA","aria-hidden":"true"}},[E._v("#")]),E._v(" 2. 进程创建")]),E._v(" "),t("ul",[t("li",[E._v("fork()拷贝当前进程创建子进程")]),E._v(" "),t("li",[E._v("子进程和父进程的区别仅在于PID,PPID和某些资源和统计量")]),E._v(" "),t("li",[E._v("exec()函数负责读取可执行文件并将其载入地址空间开始运行")])]),E._v(" "),t("h4",{attrs:{id:"3.-%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D(copy-on-write)"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#3.-%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D(copy-on-write)","aria-hidden":"true"}},[E._v("#")]),E._v(" 3. 写时拷贝(copy-on-write)")]),E._v(" "),t("ul",[t("li",[E._v("传统的fork()系统调用直接把所有的资源复制给新创建的进程，效率低下")]),E._v(" "),t("li",[E._v("写实拷贝是将拷贝推迟到需要数据写入时则拷贝，否则共享同一套映像，如fork()之后马上exec()则无需复制")])]),E._v(" "),t("h4",{attrs:{id:"4.-%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#4.-%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0","aria-hidden":"true"}},[E._v("#")]),E._v(" 4. 线程实现")]),E._v(" "),t("ul",[t("li",[E._v("线程机制提供了在同一程序内共享内存地址空间运行的一组线程，共享打开的文件和其他资源")]),E._v(" "),t("li",[E._v("Linux从内核角度来讲并无线程概念，线程被视为一个与其他进程共享某些资源的进程")])]),E._v(" "),t("h4",{attrs:{id:"5.-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#5.-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B","aria-hidden":"true"}},[E._v("#")]),E._v(" 5. 内核线程")]),E._v(" "),t("ul",[t("li",[E._v("内核线程无独立的地址空间，只在内核空间运行，可以被调度，抢占")]),E._v(" "),t("li",[E._v("内核线程只能由内核进程创建")])]),E._v(" "),t("h4",{attrs:{id:"6.-%E8%BF%9B%E7%A8%8B%E7%BB%88%E7%BB%93"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#6.-%E8%BF%9B%E7%A8%8B%E7%BB%88%E7%BB%93","aria-hidden":"true"}},[E._v("#")]),E._v(" 6. 进程终结")]),E._v(" "),t("ul",[t("li",[E._v("进程的析构是自身引起的，触发exit()系统调用")]),E._v(" "),t("li",[E._v("释放所占所有资源，通知父进程删除进程描述符")]),E._v(" "),t("li",[E._v("孤儿进程由init进程接管删除对应进程描述符")])]),E._v(" "),t("h2",{attrs:{id:"4.-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#4.-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6","aria-hidden":"true"}},[E._v("#")]),E._v(" 4. 进程调度")]),E._v(" "),t("h4",{attrs:{id:"1.-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E6%A8%A1%E5%BC%8F"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#1.-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E6%A8%A1%E5%BC%8F","aria-hidden":"true"}},[E._v("#")]),E._v(" 1. 多任务模式")]),E._v(" "),t("ul",[t("li",[E._v("抢占式，每个进程有自己运行时间片(timeslice)，如不发生抢占则运行完时间片或程序结束，可动态调整时间片")]),E._v(" "),t("li",[E._v("非抢占式， 除非程序自身主动停止，否则一直运行")])]),E._v(" "),t("h4",{attrs:{id:"2.%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#2.%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5","aria-hidden":"true"}},[E._v("#")]),E._v(" 2.调度策略")]),E._v(" "),t("ul",[t("li",[E._v("调度策略要在I/O密集和CPU密集中寻找平衡")]),E._v(" "),t("li",[E._v("进程优先级，nice值，实时优先级")])]),E._v(" "),t("h4",{attrs:{id:"3.-%E6%8A%A2%E5%8D%A0%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#3.-%E6%8A%A2%E5%8D%A0%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2","aria-hidden":"true"}},[E._v("#")]),E._v(" 3. 抢占和上下文切换")]),E._v(" "),t("ul",[t("li",[E._v("用户抢占发生在系统调用返回或者中断处理程序返回")]),E._v(" "),t("li",[E._v("内核抢占发生在中断处理程序正在执行且返回内核空间之前")])]),E._v(" "),t("h2",{attrs:{id:"5.-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#5.-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8","aria-hidden":"true"}},[E._v("#")]),E._v(" 5. 系统调用")]),E._v(" "),t("ul",[t("li",[E._v("系统调用为用户空间提供了一组硬件的抽象接口")]),E._v(" "),t("li",[E._v("系统调用保证了系统的稳定和安全")]),E._v(" "),t("li",[E._v("系统调用是用户空间访问内核的唯一手段")]),E._v(" "),t("li",[E._v("应用程序如需调用内核空间的程序则需出发软中断，来执行异常处理程序即系统调用处理程序")])]),E._v(" "),t("h2",{attrs:{id:"6.-%E4%B8%AD%E6%96%AD%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#6.-%E4%B8%AD%E6%96%AD%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86","aria-hidden":"true"}},[E._v("#")]),E._v(" 6. 中断和中断处理")]),E._v(" "),t("ul",[t("li",[E._v("中断处理程序，分为两部分，因为中断上下文具有严格的时间限制")]),E._v(" "),t("li",[E._v("中断处理程序下半部分是为了减少中断线程处理器被屏蔽的时间")]),E._v(" "),t("li",[E._v("中断处理第二部分实现")])]),E._v(" "),t("pre",{pre:!0,attrs:{class:"hljs"}},[t("code",[E._v("1.软终端\n2.tasklet\n3.工作队列\n")])]),E._v(" "),t("h2",{attrs:{id:"7.-%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E5%92%8C%E5%B9%B6%E5%8F%91"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#7.-%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E5%92%8C%E5%B9%B6%E5%8F%91","aria-hidden":"true"}},[E._v("#")]),E._v(" 7. 内核同步和并发")]),E._v(" "),t("ul",[t("li",[E._v("加锁")]),E._v(" "),t("li",[E._v("原子操作")]),E._v(" "),t("li",[E._v("信号量")]),E._v(" "),t("li",[E._v("互斥体")])]),E._v(" "),t("h2",{attrs:{id:"8.-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#8.-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86","aria-hidden":"true"}},[E._v("#")]),E._v(" 8. 定时器和时间管理")]),E._v(" "),t("ul",[t("li",[E._v("内核需在硬件的帮助下才能计算和管理时间")]),E._v(" "),t("li",[E._v("内核是靠已知的时钟中断间隔计算墙上时间和系统运行时间")]),E._v(" "),t("li",[E._v("定时器解决指定之间运行指定程序")])]),E._v(" "),t("h2",{attrs:{id:"9.-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#9.-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86","aria-hidden":"true"}},[E._v("#")]),E._v(" 9. 内存管理")]),E._v(" "),t("ul",[t("li",[E._v("内核把物理页作为内存管理的基本单位")]),E._v(" "),t("li",[E._v("处理器的最小可寻址单位是字（甚至字节）")]),E._v(" "),t("li",[E._v("内存管理单环(MMU)通常以页为单位进行处理，从虚拟内存的角度，页是最小单位")])]),E._v(" "),t("h2",{attrs:{id:"10.-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#10.-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F","aria-hidden":"true"}},[E._v("#")]),E._v(" 10. 虚拟文件系统")]),E._v(" "),t("ul",[t("li",[E._v("虚拟文件系统作为内核子系统，为用户空间程序提供了文件和文件系统相关接口")])]),E._v(" "),t("h2",{attrs:{id:"11.-%E5%9D%97i%2Fo%E5%B1%82"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#11.-%E5%9D%97i%2Fo%E5%B1%82","aria-hidden":"true"}},[E._v("#")]),E._v(" 11. 块I/O层")]),E._v(" "),t("ul",[t("li",[E._v("系统中能够随机访问固定大小数据片的硬件设备成为块设备，比如硬盘，闪存")]),E._v(" "),t("li",[E._v("字符设备按照字节流的方式被有序访问，比如串口和键盘输出字符设备")])]),E._v(" "),t("h2",{attrs:{id:"12.-%E9%A1%B5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%92%8C%E9%A1%B5%E5%9B%9E%E5%86%99"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#12.-%E9%A1%B5%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%92%8C%E9%A1%B5%E5%9B%9E%E5%86%99","aria-hidden":"true"}},[E._v("#")]),E._v(" 12. 页高速缓存和页回写")]),E._v(" "),t("ul",[t("li",[E._v("页高速缓存(cache)是linux内核实现磁盘缓存，用于减少磁盘I/O")]),E._v(" "),t("li",[E._v("内存访问速度远高于磁盘访问速度，差几个数量级")]),E._v(" "),t("li",[E._v("数据访问后有很大几率在短时间内被再次访问")]),E._v(" "),t("li",[E._v("当内核执行读操作，先会检查所需数据是否存在于高速缓存中，存在则放弃读取磁盘，缓存命中，否则读取磁盘，将数据放入高速缓存中\n-linux写缓存采用回写策略，程序写操作直接更新缓存，后端存储不立即直接更新，将页高速缓存中被写入的页标记为脏，加入脏页链表，由回写进程周期性写入磁盘")]),E._v(" "),t("li",[E._v("缓存回收策略 最少使用， 双链策略")])]),E._v(" "),t("h2",{attrs:{id:"13.-%E8%AE%BE%E5%A4%87%E4%B8%8E%E6%A8%A1%E5%9D%97"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#13.-%E8%AE%BE%E5%A4%87%E4%B8%8E%E6%A8%A1%E5%9D%97","aria-hidden":"true"}},[E._v("#")]),E._v(" 13. 设备与模块")]),E._v(" "),t("ul",[t("li",[E._v("设备类型：块设备，字符设备，网络设备")]),E._v(" "),t("li",[E._v("模块：Linux内核中用于按需加载和卸载目标码的机制")]),E._v(" "),t("li",[E._v("内核对象：内核数据结构中支持面向对象的简单操作，还支持维护对象之间的父子关系")]),E._v(" "),t("li",[E._v("sysfs：表示系统中设备树的一个文件系统")])])])}]},i=t("VU/8")(null,B,!1,null,null,null);a.default=i.exports}});
//# sourceMappingURL=2.0368309f5d33d71b1c99.js.map