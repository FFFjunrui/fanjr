webpackJsonp([12],{TRgc:function(v,a,_){"use strict";Object.defineProperty(a,"__esModule",{value:!0});var t={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var v=this,a=v.$createElement,_=v._self._c||a;return _("div",{staticClass:"content"},[_("hr"),v._v(" "),_("h2",{attrs:{id:"name%3A-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5layout%3A-posttitle%3A-%22%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%22info%3A-%22%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%22date%3A-2019-05-05categories%3A-worktags%3A-%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Dcoverimg%3A-%22https%3A%2F%2Fws1.sinaimg.cn%2Flarge%2F88b26e1cgy1fx7cwh57tlj22kw3vc1ky.jpg%22"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#name%3A-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5layout%3A-posttitle%3A-%22%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%22info%3A-%22%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E6%A6%82%E5%BF%B5%22date%3A-2019-05-05categories%3A-worktags%3A-%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Dcoverimg%3A-%22https%3A%2F%2Fws1.sinaimg.cn%2Flarge%2F88b26e1cgy1fx7cwh57tlj22kw3vc1ky.jpg%22","aria-hidden":"true"}},[v._v("#")]),v._v(' name: 数据结构和算法概念\nlayout: post\ntitle:  "数据结构和算法概念"\ninfo: "数据结构和算法概念"\ndate:   2019-05-05\ncategories: WORK\ntags: [数据结构]\ncoverimg: "https://ws1.sinaimg.cn/large/88b26e1cgy1fx7cwh57tlj22kw3vc1ky.jpg"')]),v._v(" "),_("h5",{attrs:{id:"%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95","aria-hidden":"true"}},[v._v("#")]),v._v(" 数学归纳法")]),v._v(" "),_("ul",[_("li",[v._v("数学归纳法是一种数学证明方法，常用于证明命题在自然数范围内成立")])]),v._v(" "),_("h5",{attrs:{id:"%E9%80%92%E5%BD%92"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#%E9%80%92%E5%BD%92","aria-hidden":"true"}},[v._v("#")]),v._v(" 递归")]),v._v(" "),_("ul",[_("li",[v._v("递归是指一个计算机程序调用其自身，必须设置退出递归条件")]),v._v(" "),_("li",[v._v("递归是数学归纳法在计算机程序中的实现，只关注初始条件和衔接，不关心具体每一步")]),v._v(" "),_("li",[v._v("实现递归算法可手动实现栈可以提高运行效率")])]),v._v(" "),_("h5",{attrs:{id:"%E6%A0%88"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#%E6%A0%88","aria-hidden":"true"}},[v._v("#")]),v._v(" 栈")]),v._v(" "),_("ul",[_("li",[v._v("递归是用栈数据结构实现的")]),v._v(" "),_("li",[v._v("递归是函数对自身的调用，用栈来保存函数调用未返回的状态")])]),v._v(" "),_("h5",{attrs:{id:"%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95","aria-hidden":"true"}},[v._v("#")]),v._v(" 排序算法")]),v._v(" "),_("ul",[_("li",[v._v("冒泡排序")]),v._v(" "),_("li",[v._v("插入排序")]),v._v(" "),_("li",[v._v("选择排序")]),v._v(" "),_("li",[v._v("希尔排序")]),v._v(" "),_("li",[v._v("并归排序")]),v._v(" "),_("li",[v._v("快速排序")]),v._v(" "),_("li",[v._v("堆排序")])]),v._v(" "),_("h5",{attrs:{id:"%E9%93%BE%E8%A1%A8"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#%E9%93%BE%E8%A1%A8","aria-hidden":"true"}},[v._v("#")]),v._v(" 链表")]),v._v(" "),_("ul",[_("li",[v._v("链表储存为分散的节点，每个节点包含一个元素，以及指向上一个元素的指针")]),v._v(" "),_("li",[v._v("第一个节点为头节点，这个节点不用于存储元素，只是用于标记链表的起始，可方便让我们插入或者删除表的第一个元素")]),v._v(" "),_("li",[v._v("最后一个节点的指针为NULL")]),v._v(" "),_("li",[v._v("链表的功能和数组很像，数组也是有序元素集合，单数组在内存中是一段连续的内存，而链表的每个节点占据的内存可以是离散的")]),v._v(" "),_("li",[v._v("在数组中可以通过索引来获取某个元素，在链表中必须沿着指针联系起长链，遍历查询元素")]),v._v(" "),_("li",[v._v("数组有固定的大小，链表可以根据运行情况插入或者删除节点，动态的更改大小")]),v._v(" "),_("li",[v._v("链表插入节点时需要从进程空间的堆中开辟内存空间，用以存储节点，删除节点可以将节点占据的内存归还给进程空间")]),v._v(" "),_("li",[v._v("链表可分为单向链表，双向链表，循环链表，双向循环链表")])]),v._v(" "),_("h5",{attrs:{id:"%E6%A0%88-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#%E6%A0%88-2","aria-hidden":"true"}},[v._v("#")]),v._v(" 栈")]),v._v(" "),_("ul",[_("li",[v._v("栈是有序的元素集合，最显著的特征是LIFO后进先出")]),v._v(" "),_("li",[v._v("栈中的每一个元素称为一个frame,最上层的元素称为top frame")]),v._v(" "),_("li",[v._v("栈只支持三种操作，pop, top, push")]),v._v(" "),_("li",[v._v("pop取出栈中最上层元素并删除它，栈的最上层元素变为早先进入的元素")]),v._v(" "),_("li",[v._v("top查看栈的最上层元素")]),v._v(" "),_("li",[v._v("push将一个新元素放到栈的最上层")]),v._v(" "),_("li",[v._v("栈最经典的计算机应用是函数调用，每个进程都会有一个栈，每个frame中记录了函数调用的参数，自动变量和返回地址，当该函数调用一个新的函数时，栈中会push一个frame，当函数执行完毕返回时，该frame会pop，从而进入调用该函数的原函数继续执行")]),v._v(" "),_("li",[v._v("栈是限定了操作的有序的元素集合，所以栈的实现可以在数组也可以在链表的基础实现")])]),v._v(" "),_("h5",{attrs:{id:"%E9%98%9F%E5%88%97(queue)"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#%E9%98%9F%E5%88%97(queue)","aria-hidden":"true"}},[v._v("#")]),v._v(" 队列(queue)")]),v._v(" "),_("ul",[_("li",[v._v("队列最大特性是先进先出(FIFO)")]),v._v(" "),_("li",[v._v("队列支持两个操作队首的元素离开队列(dequeue),和新元素加入队尾(enqueue)")]),v._v(" "),_("li",[v._v("队列在计算机中的应用广泛，一个经典的应用是消息队列")]),v._v(" "),_("li",[v._v("和栈相似，队列的实现可以是链表和数组")])]),v._v(" "),_("h5",{attrs:{id:"%E6%A0%91"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#%E6%A0%91","aria-hidden":"true"}},[v._v("#")]),v._v(" 树")]),v._v(" "),_("ul",[_("li",[v._v("树是元素的集合")]),v._v(" "),_("li",[v._v("该集合可以为空，这时树中没有元素，被称为空树")]),v._v(" "),_("li",[v._v("如果该集合不为空，那么该集合有一个根节点，以及0个或者多个子树，根节点与他的子树用一个边连接")]),v._v(" "),_("li",[v._v("树的子节点数目是不确定的，这种不确定性可能带来大量的内存相关操作，并且容易造成内存浪费")]),v._v(" "),_("li",[v._v("拥有同一个父节点的两个节点互为兄弟节点")]),v._v(" "),_("li",[v._v("计算机的文件系统是树的结构，在UNIX的文件系统中，每个文件(文件夹)都可以看作是一个节点")]),v._v(" "),_("li",[v._v("非文件夹的文件被存储在叶节点，文件夹中有指向父节点和子节点的指针")]),v._v(" "),_("li",[v._v("二叉树是一种特殊的树，二叉树的每个节点最多只能有两个子节点")]),v._v(" "),_("li",[v._v("二叉搜索树为每个节点都比它左子树的任意元素大，而且比它的右子树的任意元素大")]),v._v(" "),_("li",[v._v("删除节点相对比较复杂，有时需要进行一定的调整，以恢复二叉搜索树的性质")]),v._v(" "),_("li",[v._v("子叶节点可以直接删除")]),v._v(" "),_("li",[v._v("惰性删除，并不真实的从二叉搜索树中删除该节点，而是将该节点标记为已删除，如果有相同元素从新插入，则直接取消该元素的删除")]),v._v(" "),_("li",[v._v("惰性删除树占据的内存空间不会因为删除节点而减少，是用内存空间换取操作的简便性")])]),v._v(" "),_("h5",{attrs:{id:"avl%E6%A0%91"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#avl%E6%A0%91","aria-hidden":"true"}},[v._v("#")]),v._v(" AVL树")]),v._v(" "),_("ul",[_("li",[v._v("AVL树的要求，任意节点的左子树深度和右子树深度相差不超过1")]),v._v(" "),_("li",[v._v("当执行插入动作，可能需执行节点旋转操作来实现AVL树的要求")]),v._v(" "),_("li",[v._v("AVL树通过动态平衡树的深度，单次搜索的复杂度为log(n)")])]),v._v(" "),_("h5",{attrs:{id:"%E4%BC%B8%E5%B1%95%E6%A0%91"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#%E4%BC%B8%E5%B1%95%E6%A0%91","aria-hidden":"true"}},[v._v("#")]),v._v(" 伸展树")]),v._v(" "),_("ul",[_("li",[v._v("二叉搜索树类似，伸展树的单次搜索也可能需要n次操作。但伸展树可以保证，m次的连续搜索操作的复杂度为mlog(n)的量级，而不是mn量级")])]),v._v(" "),_("h5",{attrs:{id:"%E5%A0%86(heap)"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#%E5%A0%86(heap)","aria-hidden":"true"}},[v._v("#")]),v._v(" 堆(heap)")]),v._v(" "),_("ul",[_("li",[v._v("堆又被成为优先队列，但在堆中不是按照元素的先后顺序取出元素的，而是按照元素的优先级取出元素")]),v._v(" "),_("li",[v._v("Linux内核中的调取器会按照每个进程的优先级来安排CPU执行哪一个进程")]),v._v(" "),_("li",[v._v("Linux中可以使用nice命令来影响进程的优先级")]),v._v(" "),_("li",[v._v("堆的一个经典实现是完全二叉树，这样实现的堆称为二叉堆")]),v._v(" "),_("li",[v._v("堆的主要操作是插入和删除最小元素，在插入或者删除操作之后，必须保持该实现应有的性质，1.完全二叉树，2.每个节点的值都小于等于它的子节点")])]),v._v(" "),_("h5",{attrs:{id:"%E5%B7%A6%E5%80%BE%E5%A0%86"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#%E5%B7%A6%E5%80%BE%E5%A0%86","aria-hidden":"true"}},[v._v("#")]),v._v(" 左倾堆")]),v._v(" "),_("ul",[_("li",[v._v("左倾堆基于二叉树，左倾堆的节点满足堆的基本要求，每个节点的优先级大于子节点的优先级")]),v._v(" "),_("li",[v._v("左倾堆并不是完全二叉树，它的左子树节点往往比右子树右更多的节点")]),v._v(" "),_("li",[v._v("左倾堆的任意子树也是一个左倾堆")])]),v._v(" "),_("h5",{attrs:{id:"hash"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hash","aria-hidden":"true"}},[v._v("#")]),v._v(" HASH")]),v._v(" "),_("ul",[_("li",[v._v("哈希表(hash table)是从一个集合A到另一个集合B的映射(mapping)")]),v._v(" "),_("li",[v._v("在没有hash碰撞的前提下，我们只需要选择一次，就可以保证该下标指向的元素是我们想要的元素")]),v._v(" "),_("li",[v._v("当发生哈希冲突时，一个方案是将发生冲突的记录用链表储存起来，让hash值指向该链表，这叫做open hashing")])]),v._v(" "),_("h5",{attrs:{id:"%E5%9B%BE"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#%E5%9B%BE","aria-hidden":"true"}},[v._v("#")]),v._v(" 图")]),v._v(" "),_("ul",[_("li",[v._v("图是一种比较松散的数据结构，树是一种特殊的图，但限制性更强一些")]),v._v(" "),_("li",[v._v("图分为有向图和无向图")]),v._v(" "),_("li",[v._v("无权网络和加权网络")]),v._v(" "),_("li",[v._v("拓扑排序")])])])}]},i=_("VU/8")(null,t,!1,null,null,null);a.default=i.exports}});
//# sourceMappingURL=12.c968194696d3308248f2.js.map