{"version":3,"sources":["webpack:///./src/posts/网络协议.md?ef9b","webpack:///./src/posts/网络协议.md"],"names":["____","render","this","$createElement","_self","_c","_m","staticRenderFns","_vm","_h","staticClass","_v","attrs","id","href","aria-hidden","Component","__webpack_require__","normalizeComponent","__webpack_exports__"],"mappings":"uGAAA,IAGeA,GADEC,OAFjB,WAA0BC,KAAaC,eAAbD,KAAuCE,MAAAC,GAAwB,OAA/DH,KAA+DI,GAAA,IAExEC,iBADjB,WAAoC,IAAAC,EAAAN,KAAaO,EAAAD,EAAAL,eAA0BE,EAAAG,EAAAJ,MAAAC,IAAAI,EAAwB,OAAAJ,EAAA,OAAiBK,YAAA,YAAsBL,EAAA,MAAAG,EAAAG,GAAA,KAAAN,EAAA,MAAgCO,OAAOC,GAAA,oWAAuWR,EAAA,KAAUK,YAAA,gBAAAE,OAAmCE,KAAA,kWAAAC,cAAA,UAA+XP,EAAAG,GAAA,OAAAH,EAAAG,GAAA,wMAAAH,EAAAG,GAAA,KAAAN,EAAA,MAA0PO,OAAOC,GAAA,iCAAoCR,EAAA,KAAUK,YAAA,gBAAAE,OAAmCE,KAAA,+BAAAC,cAAA,UAA4DP,EAAAG,GAAA,OAAAH,EAAAG,GAAA,UAAAH,EAAAG,GAAA,KAAAN,EAAA,OAAAA,EAAA,QAAAG,EAAAG,GAAA,4HAAAH,EAAAG,GAAA,KAAAN,EAAA,MAA0NO,OAAOC,GAAA,iCAAoCR,EAAA,KAAUK,YAAA,gBAAAE,OAAmCE,KAAA,+BAAAC,cAAA,UAA4DP,EAAAG,GAAA,OAAAH,EAAAG,GAAA,UAAAH,EAAAG,GAAA,KAAAN,EAAA,OAAAA,EAAA,QAAAG,EAAAG,GAAA,8sBAAAH,EAAAG,GAAA,KAAAN,EAAA,MAA4yBO,OAAOC,GAAA,iCAAoCR,EAAA,KAAUK,YAAA,gBAAAE,OAAmCE,KAAA,+BAAAC,cAAA,UAA4DP,EAAAG,GAAA,OAAAH,EAAAG,GAAA,UAAAH,EAAAG,GAAA,KAAAN,EAAA,OAAAA,EAAA,QAAAG,EAAAG,GAAA,opCAAAH,EAAAG,GAAA,KAAAN,EAAA,MAAkvCO,OAAOC,GAAA,iCAAoCR,EAAA,KAAUK,YAAA,gBAAAE,OAAmCE,KAAA,+BAAAC,cAAA,UAA4DP,EAAAG,GAAA,OAAAH,EAAAG,GAAA,UAAAH,EAAAG,GAAA,KAAAN,EAAA,OAAAA,EAAA,QAAAG,EAAAG,GAAA,8uEAAAH,EAAAG,GAAA,KAAAN,EAAA,MAA40EO,OAAOC,GAAA,iCAAoCR,EAAA,KAAUK,YAAA,gBAAAE,OAAmCE,KAAA,+BAAAC,cAAA,UAA4DP,EAAAG,GAAA,OAAAH,EAAAG,GAAA,UAAAH,EAAAG,GAAA,KAAAN,EAAA,OAAAA,EAAA,QAAAG,EAAAG,GAAA,gpGCYt+MK,EAbyBC,EAAQ,OAajCC,CAXA,KAaElB,GATF,EAEA,KAEA,KAEA,MAUemB,EAAA,QAAAH,EAAiB","file":"static/js/3.230c96f7967bf53bd013.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_c('hr'),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"name%3A-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AElayout%3A-posttitle%3A-%22%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%22info%3A-%22%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%22date%3A-2019-05-05categories%3A-worktags%3A-%5B%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%2C-tcp%2Fip%5Dcoverimg%3A-%22https%3A%2F%2Fws1.sinaimg.cn%2Flarge%2F88b26e1cgy1fx7cwh57tlj22kw3vc1ky.jpg%22\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#name%3A-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AElayout%3A-posttitle%3A-%22%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%22info%3A-%22%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%22date%3A-2019-05-05categories%3A-worktags%3A-%5B%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%2C-tcp%2Fip%5Dcoverimg%3A-%22https%3A%2F%2Fws1.sinaimg.cn%2Flarge%2F88b26e1cgy1fx7cwh57tlj22kw3vc1ky.jpg%22\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" name: 网络协议\\nlayout: post\\ntitle:  \\\"网络协议\\\"\\ninfo: \\\"网络协议\\\"\\ndate:   2019-05-05\\ncategories: WORK\\ntags: [网络协议, TCP/IP]\\ncoverimg: \\\"https://ws1.sinaimg.cn/large/88b26e1cgy1fx7cwh57tlj22kw3vc1ky.jpg\\\"\")]),_vm._v(\" \"),_c('h3',{attrs:{\"id\":\"%E7%89%A9%E7%90%86%E5%B1%82\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#%E7%89%A9%E7%90%86%E5%B1%82\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" 物理层\")]),_vm._v(\" \"),_c('pre',[_c('code',[_vm._v(\"物理层是由光纤，电缆或者电磁波等真实处在的物理媒介\\n这些媒介可以传递物理信号，比如亮度，电压或者振幅\\n数字应用使用两种物理信号分别表示1和0，高电压表示1，低电压表示0\\n操作系统有响应的接口来接受物理信号并解读成0/1序列\\n\")])]),_vm._v(\" \"),_c('h3',{attrs:{\"id\":\"%E8%BF%9E%E6%8E%A5%E5%B1%82\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#%E8%BF%9E%E6%8E%A5%E5%B1%82\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" 连接层\")]),_vm._v(\" \"),_c('pre',[_c('code',[_vm._v(\"在连接层信息已帧(frame)为单位传输，帧是一段有限的0/1序列\\n连接层协议的功能就是识别0/1序列中所包含的帧，识别帧的起始\\n连接层协议不关心数据中包含什么，帧就像一个信封吧数据包裹起来\\n以太网和WIFI是现在最常见的连接层协议\\n一个帧中只能记录SRC和DST两个地址\\n\\n头部\\n    前7个byte为序言，为了让接收设备调整接收频率，以便与发送设备的频率一致，这个过程就叫做时钟复原\\n    SFD为起始信号\\n    紧随SFD之后的是6 byte的目的地(DST, destination)和6byte的发出地(SRC, source)\\n    MAC地址是物理设备自带的序号，只能在同一个以太网中被识别\\n    头部的最后一个区域是Type，用以说明数据部分的类型。(比如0x0800为IPv4，0x0806为ARP)\\n数据\\n    数据一般包含有符合更高层协议的数据，比如IP包\\n    连接层协议本身并不在乎数据是什么，它只负责传输\\n    数据尾部可能填充有一串0(PAD区域)。原因是数据需要超过一定的最小长度\\n尾部\\n    跟随在数据之后的是校验序列\\n    通过使用高压/低压，高频率/低频率等物理信号来表示0/1可能会出现误差\\n    使用CRC算法来验证最后一位\\n\\n交换机\\n    交换机记录各个设备的MAC地址，当帧发送到交换机时，交换机会检查DST,然后只发送到对应端口\\n    \\nWIFI\\n    WIFI的工作方式与集线器连接下的以太网很相似，一个WIFI设备会向所有WIFI设备发送帧，其他WIFI设备检查是否符合DST，故不安全\\n\")])]),_vm._v(\" \"),_c('h3',{attrs:{\"id\":\"%E7%BD%91%E7%BB%9C%E5%B1%82\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#%E7%BD%91%E7%BB%9C%E5%B1%82\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" 网络层\")]),_vm._v(\" \"),_c('pre',[_c('code',[_vm._v(\"1.可以从物理层上在两个网络的接收和发送0/1序列\\n2.可以同时理解两种网络的帧格式\\n路由器的多个网卡可接入多个网络，并理解相应的连接层协议，在帧经过路由到达另一个网络的时候，路由器会读取帧的信息，并改写以发送到另一个网络\\nWIFI PC1 -> 路由器WIFI接口 -> 路由以太网接口 -> 以太网 PC2\\n\\n各个局域网根据IP协议互相连接，构成覆盖全球的Internet\\n更高层的协议，无论是TCP还是UDP，必须通过网络层的IP数据包(datagram)来传递信息。操作系统也会提供该层的socket，从而允许用户直接操作IP包\\nIPv4共有32位，第一部分来区分局域网，第二部分用来区分局域网内的主机，分类A，B，C类网络\\nIPv4地址耗尽，出现128位IPv6协议，由于格式不兼容，目前的很多互联网资产和老路由器只支持IPv4，故迁移进度很慢\\n\\nIP地址识别的是网卡，网卡在接受网络信息之后将信息交给计算机(处理器/内存)，发送信息也通过网卡\\n\\n路由器实际上是一台配置有多个网卡的专用电脑\\n\\nIP包的传输要通过路由器的接力。每一个主机和路由中都存有一个路由表\\n路由表根据目的地的IP地址，规定了等待发送的IP包所应该走的路线\\n发送整个过程中，IP包不断被主机和路由封装入帧(信封)并拆开，然后借助连接层，在局域网的各个NIC之间传送帧\\n每一台主机或路由中都有一个ARPcache，用以存储局域网内IP地址和MAC地址如何对应。\\nRIP协议通过距离来决定生成路由表\\nRIP出于技术上的原因(looping hops)，认为距离超过15的IP不可到达，电信，联通，移动\\n各个边界路由器之间通过BGP来生成自己前往其它AS的路由表，而自治系统内部则参照边界路由器，使用RIP来决定路由表\\n\\nICMP\\n\\n    ICMP协议是介于网络层和传输层的协议。它的主要功能是传输网络诊断信息\\n    ICMP传输的信息可以分为两类，一类是错误(error)信息，这一类信息可用来诊断网络故障，当发生提供特定类型的错误，可将错误信息汇报给上游，实现尽量可靠\\n    另一类信息是咨询性质的，比如某台计算机询问路径上的每个路由器都是谁，然后各个路由器同样用ICMP包回答\\n    ICMP基于IP协议。也就是说，一个ICMP包需要封装在IP包中，然后在互联网传送\\n    ICMP是IP套装的必须部分，也就是说，任何一个支持IP协议的计算机，都要同时实现ICMP\\n    \\n    ICMP却经常被黑客借用进行网络攻击，比如利用伪造的IP包引发大量的ICMP回复，并将这些ICMP包导向受害主机，从而形成DoS攻击\\n    选择忽视某些类型的ICMP包来提高自身的安全性\\n\")])]),_vm._v(\" \"),_c('h3',{attrs:{\"id\":\"%E4%BC%A0%E8%BE%93%E5%B1%82\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#%E4%BC%A0%E8%BE%93%E5%B1%82\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" 传输层\")]),_vm._v(\" \"),_c('pre',[_c('code',[_vm._v(\"上面三层协议实现不同计算机之前通信，但计算机中有很多进程需要通信\\n传输层协议TCP，\\nUDP\\n    UDP与传统的IP传输相似，可认为是IP协议暴露在传输层的一个接口，来实现端口的与不同进程通讯，所有UDP是不可靠的\\n    UDP协议晚于TCP协议，可减轻网络连接成本，并实现端口概念\\n    \\n端口\\n    端口是伴随着传输层诞生的概念，将网络层IP通信分送到各个进程\\n\\nSokcet\\n    进入传输层我们可以调用操作系统中的API来构建socket，socket是操作系统提供的一个编程接口，用来代表某个网络通信\\n    应用程序通过socket来调用系统内核中处理网络协议的模块，而这些内核模块会负责具体的网络协议的实施\\n    内核来接收网络协议的细节，而我们只需要提供所要传输的内容就可以了，内核会帮我们控制格式，并进一步向底层封装\\n    \\nTCP\\n    TCP协议是传输层协议，实现的是端口到端口(port)的通信，TCP协议虚拟了文本流的通信\\n    计算机的功能就是储存和处理文本流。CPU+memory+存储设备实现了文本流在同一台计算机内部的加工处理。\\n    通过一些IO，比如屏幕和键盘，文本流实现了人机交互\\n    如果网络通信可在不同计算机之间进行文本流的交互，那么我们就和整个计算机系统的数据处理方式实现了对接\\n    \\n    TCP协议确保了数据到达的顺序与文本流顺序相符\\n    超过MTU的数据会被分成多个IP包发送\\n    给文本流分段是在发送主机完成的，而碎片化是在网络中的路由器完成的，在主机分好段可减轻网络负担\\n    TCP片段的头部(header)会存有该片段的序号，来实现顺序形成流\\n    TCP对端在每收到一个正确的、符合次序的片段之后，就向发送方发送一个ACK回复\\n    通过ACK回复和重新发送机制，TCP协议将片段传输变得可靠\\n    使用滑窗在一定程度上实现了对乱序数据的缓存，提高效率\\n    \\n    TCP的连接是双向的\\n    1. 一个TCP头部需要包含出发端口(source port)和目的地端口(destination port)。这些与IP头中的两个IP地址共同确定了连接。\\n    2. 每个TCP片段都有序号(sequence number)。这些序号最终将数据部分的文本片段整理成为文本流。\\n    3. ACK是一位(bit)。只有ACK位设定的时候，回复号(Acknowledgement number)才有效。ACK回复号说明了接收方期待接收的下一个片段，所以ACK回复号为最后接收到的片段序号加1\\n    4. ACK后面还有SYN和FIN，它们也各占据一位(bit)\\n    \\n    连接的建立\\n        连接建立的最重要的目的是交换双方初始序号，TCP协议规定第一个片段的序号不能是定值\\n        ISN交换是通过SYN片段实现的。SYN片段由头部的SYN位表明，它的序号为发送方的ISN\\n        TCP传输的规则，接收到ISN的一方需要回复ACK，所以共计四片信息在建立连接过程中传输。之所以是三次握手，是因为server将发送SYN和回复ACK合并到一个TCP片段中\\n      \\n      连接的正常终结\\n        连接终结的过程中，连接双方也交换了四片信息两个FIN和两个ACK\\n        在终结连接的过程中，TCP并没有合并FIN与ACK片段。原因是TCP连接允许单向关闭，TCP连接关闭了一个方向的传输，成为一个单向连接(half-duplex)\\n        \\n    TCP是连接导向的协议，与之对应的是像UDP这样的非连接导向的协议。连接能带来更好的传输控制，但也需要更多额外的工作，比如连接的建立和终结\\n    \\n    通过滑窗与ACK的配合，我们一方面实现了TCP传输的可靠性，另一方面也一定程度上提高了效率\\n    通过将ACK回复“附着”在其他数据片段的方式，和累计ACK回复，减少了ACK回复所消耗的流量\\n    通过流量管理，TCP连接两端的工作能力可以匹配，从而减少不不要的传输浪费\\n    TCP协议会根据情况自动改变滑窗大小，以实现流量控制\\n    滑动窗口大小有可能变为0，这意味着接收方的接收能力降为0，发送方停止发送\\n    发送方会在零窗口后，不断探测接收方的窗口，如果依然为0，发送方会等待更长的时间，然后再次进行窗口探测，直到TCP传输恢复\\n    TCP协议规定发送方和接收方窗口必须达到一定尺寸方可发送\\n    \\n    包裹在IP包内的的TCP片段可能发生丢包，经过太多路由达到hop limit,路由太过拥挤，路由表没有及时更新等原因\\n    接受方发现TCP片段出错会丢弃TCP片段\\n    \\n    两种重新发送TCP片段的机制：超时重新发送快速重新发送\\n    堵塞控制\\n        发送速率总是在增长。如果片段丢失，则重置速率为1，并快速增长\\n        增长到一定程度，则进入到慢性增长。快速增长和慢性增长的切换点会随着网络状况(何时出现片段丢失)更新\\n        通过上面的机制，让发送速率处于动态平衡，不断的尝试更大值。初始时增长块，而接近饱和时增长慢。但一旦尝试过度，则迅速重置，以免造成网络负担\\n\")])]),_vm._v(\" \"),_c('h3',{attrs:{\"id\":\"%E5%BA%94%E7%94%A8%E5%B1%82\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#%E5%BA%94%E7%94%A8%E5%B1%82\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" 应用层\")]),_vm._v(\" \"),_c('pre',[_c('code',[_vm._v(\"通过以上协议可以实现任意两个进程之间通信\\n应用层协议有FTP，HTTP，IMAP\\nDNS\\n    DNS负责将域名转换为对应IP地址\\n    DNS协议主要基于UDP，是应用层协议\\n    整个DNS查询过程中，无论是重新定向还是最终取得对应关系，都是用户计算机和DNS服务器使用DNS协议通信\\n    用户计算机根据DNS服务器的反馈，依次与下一层的DNS服务器建立通信。用户计算机经过递归查询，最终和末端节点通信，并获得IP地址\\n    并不是每次域名解析都要完整的经历解析过程。DNS Resolver通常有DNS缓存(cache)，用来记录最近使用和查询的域名/IP关系\\n    \\nHTTP\\n    TCP协议实现了数据流的传输。然而，人们更加习惯以文件为单位传输资源，比如文本文件，图像文件，超文本文档\\n    HTTP协议解决文件传输的问题。HTTP是应用层协议，主要建立在TCP协议之上(偶尔也可以UDP为底层)。它随着万维网的发展而流行。HTTP协议目的是，如何在万维网的网络环境下，更好的利用TCP协议，以实现文件，特别是超文本文件的传输。\\n\\n    格式\\n        GET /index.html HTTP/1.1\\n        Host: www.example.com\\n\\n        起始行只有一行。它包含了请求/回复最重要的信息。请求的起始行表示客户端请求资源。回复的起始行表示服务器回复\\n        \\n        头信息可以有多行。每一行是一对键值对，头信息是对起始行的补充。请求的头信息对服务器有指导意义，回复的头信息则是提示客户端\\n        \\n        主体部分包含了具体的资源\\n        \\n    请求\\n        在起始行有三段信息\\n            1.请求方法\\n            2.请求资源路径\\n            3.HTTP版本号1.0/1.1\\n        \\n        头信息中有字段Host表示服务器域名，默认端口为80\\n        \\n    响应\\n        HTTP/1.1 200 OK\\n        Content-type: text/plain\\n        Content-length: 12\\n        \\n        Hello World!\\n        \\n        起始行信息\\n            1.HTTP协议版本\\n            2.状态码\\n            3.状态描述\\n            \\n        Content-type说明了主体所包含的资源的类型\\n            text/plain 普通文本\\n            text/html HTML文本\\n            image/jpeg jpeg图片\\n            image/gif gif图片\\n\\n        Content-length说明了主体部分的长度，以字节(byte)为单位。\\n        \\n        回应的主体部分为一段普通文本，即Hello World!\\n        \\n    无状态\\n        HTTP通信是无状态的。服务器认为每次请求都是一个全新的请求\\n        \\n        随着HTTP协议的发展，HTTP协议允许TCP连接复用，以节省建立连接所耗费的时间。但HTTP协议依然保持无状态的特性。\\n\\nDHCP\\n    DHCP协议全称为“动态主机设置协议”\\n    动态获取IP过程\\n        1.普通电脑中都内置有DHCP客户端模块。\\n        2.电脑接上网络后，DHCP客户端发现新连通的网络，会在该网络上找DHCP服务器。\\n        3.DHCP服务器将给电脑提供合理的网络配置，并把设置信息传回本机\\n        4.所谓的DHCP服务器，其实就是一些运行有DHCP服务器端软件的特殊电脑\\n        5.本机和DHCP服务器之间的通信，都是通过DHCP协议进行的\\n    地址分配\\n        地址分配原则：1.地址合法，即对应该局域网的IP地址和子网掩码，2.地址空闲，同一网络下没有其他设备使用该地址。\\n        DHCP服务器上存有一个地址池，里面是可用的IP地址\\n        当有客户端请求DHCP服务器会从地址池返回一个IP给客户端，IP有TTL\\n        如果主机在TTL到期之前没有续约DHCP服务器，DHCP服务器会回收IP地址\\n        有了动态分配，DHCP服务器不但简化了网络配置过程，还可以有效利用IP地址资源\\n        DHCP服务器会预留一些地址给特定MAC地址的设备使用\\n        \\n    通信过程\\n        DHCP协议底层是UDP协议，DHCP通信主要靠广播的形式进行\\n        \\n        1.Discovery：客户机发广播，搜寻DHCP服务器。\\n        2.Offer：DHCP服务器发出邀请，提供一个可用的IP地址。\\n        3.Request：客户机正式请求使用该IP地址。\\n        4.Acknowledge：DHCP服务器确认，并提供其他配置参数。\\n        \\n        每一步的通信内容都放在一个符合DHCP格式的数据包中。\\n        数据包中可以包括客户机IP地址、服务器IP地址、客户的硬件MAC编号等字段，还能附加多条网络设置参数。\\n        当某些信息未知时，如客户机的IP地址，相应的字段可以填成0。\\n        为了防止DHCP服务器不靠谱，客户机通常还会探测一下网络，以免该IP已经被其他设备占用。\\n        除了租期，DHCP服务器最终确认中，还可能加上其他网络配置信息，如DNS服务器地址、网络出口地址等。\\n        客户机可以选择接受，也可以拒绝DHCP服务器的“好意”，自行设置这些参数。\\n    DHCP攻击\\n        1.DHCP的一种攻击办法是从服务器那里骗IP地址，导致DHCP服务器地址耗尽，无法分配给正常用户\\n        2.攻击者占有了大量IP地址，可以装扮成新的DHCP服务器，把自己骗来的IP地址分配给网络上的新用户。\\n        3.DHCP服务器还能提供其他网络设置参数。攻击者可以让自己成为DNS服务器或者网络出口\\n        \\nSSL/TLS\\n    TLS名为传输层安全协议(Transport Layer Security Protocol)，这个协议是一套加密的通信协议。\\n    TLS的前身是SSL协议(安全套接层协议，Secure Sockets Layer), 这两个协议的工作方式类似，但TLS协议针对SSL协议进行了一些改善。\\n    SSL/TLS协议利用加密的方式，在开放的互联网环境中实现了加密通信，让通信的双方可以安心的说悄悄话\\n    \\n    加密和解密用的是同一个密钥，这种加密称为对称加密\\n    钥匙和锁分离的加密算法就叫做非对称加密\\n    RSA加密算法牛逼\\n    SSL协议，没看懂\\n    \\n利用CIDR，我们可以将IP地址根据需要进行分割，从而不浪费IP地址\\n\\nNAT(Network Address Translation)\")])])])}]\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-83ff7818\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./build/markdown!./src/posts/网络协议.md\n// module id = null\n// module chunks = ","var normalizeComponent = require(\"!../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nvar __vue_script__ = null\n/* template */\nimport __vue_template__ from \"!!../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-83ff7818\\\",\\\"hasScoped\\\":false,\\\"buble\\\":{\\\"transforms\\\":{}}}!../../node_modules/vue-loader/lib/selector?type=template&index=0!../../build/markdown/index.js!./网络协议.md\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = null\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/posts/网络协议.md\n// module id = null\n// module chunks = "],"sourceRoot":""}